\chapter{Static Declarative Symbolic Reasoning}\label{c:main-content}

In this chapter we present our approach towards static declarative
symbolic reasoning. The main core of the reasoning is encoded as a
bunch of Souffle Datalog rules, along with the related input facts.
\doop{} includes a whole of preprocessing, expressive analyses and
postprocessing pieces that can be leveraged to enhance the core of
our reasoning at relatively swift speed.

\section{Schema Relations and Types}

\subsection{Input Facts and Types}

\doop{} includes a set of fact generators that provide us with an
extensive set of input facts that may be leveraged for our reasoning.
Those generators either target different input languages or different
intermediate representations (IR). As an example, there are generators
that target the Java language, Android technology or Python. Those
generators may further utilize different tools that would take care
the translation of the input program into the corresponding IR; the
current tools being used by \doop{} are namely Soot and WALA. In the case of
Java, the generators ought to produce the same set of input facts
that \doop{} consumes for its main analyses, and thus there is a set
of files that define the common predicates-facts that should be
produced by the generators. The existing set of generated
facts is quite extensive and it is constantly further enriched, yet it
does not provide us with a set of facts crucial for the reasoning
we introduce. Hosting a rich whole of various pointer analyses,
\doop{} mainly needs knowledge that is related to pointers, or
in the Java setting reference types. As such, \doop{} lacks
presence of multiple facts in regard to primitive types or
values and in the case that they exist they are relatively
non-adequate. In that notion we decided to modify the common fact
generator in a way that enhances \doop{} with facts to be consumed
by our symbolic reasoning approach, or modifies several existing ones.
At the same time those facts may also come handy for \doop{} itself
in the future. In order to be able to construct a fine-grained
analysis we modified a certain amount of facts as follows in figure \ref{fig:facts-modified}.

\begin{figure}[th]
\rel{\_AssignOperFrom}{instruction, position, from}.\\
\rel{\_IfVar}{instruction, position, var}.
\captionof{figure}{Modified \doop{} facts}
\label{fig:facts-modified}
\end{figure}

\_AssignOperFrom introduces a new position variable that keeps track of
each subsequent operand of an instruction's right-hand side (rhs), whilst
the same also holds for \_IfVar too. Next, we provide a glimpse of all the
newly introduced generated facts in figure \ref{fig:facts-new}.

\begin{figure}[th]
  \rel{\_OperatorAt}{instruction, operator}.\\
  \rel{\_DummyIfVar}{instruction, var}.\\
  \rel{\_AssignOperFromConstant}{instruction, position, from}.\\
  \rel{\_IfConstant}{instruction, position, constant}.
  \captionof{figure}{New \doop{} facts}
  \label{fig:facts-new}
\end{figure}

Those input facts share many similarities in regards to the associated
variables - relation columns - though each one encodes crucial knowledge.
The \_OperatorAt relation holds facts that encode the operation being present
at a given instruction. \_AssignOperFromConstant is an alternate rule of \_AssignOperFrom,
whilst \_IfConstant is equivalent to \_IfVar. A constant type is different to a variable type
in the context of the framework, thus the need for a more detailed differentiation between the
two. Such differentiations have extensively been made during the development of our approach, but
in many cases will be omitted in the context of this text.
Lastly, the \_DummyIfVar relation has been introduced in order to encode the conditional
expressions at a given branch instruction, that is quite necessary to our implementation
and its need is evoked due to the IR provide by Soot. It is also worth mentioning that
the facts and the associated relations as described above are provided by the generators
written in Java. Mere preprocessing takes place before importing the final facts into \doop{}'s
knowledge base in order to follow its conventions. That preprocessing leads to the following
renames as described in figure \ref{fig:imported-facts}.

\begin{figure}[th]
  \rel{AssignOper\_From}{instruction, position, from}.\\
  \rel{AssignOper\_FromConstant}{instruction, position, from}.\\
  \rel{If\_Var}{instruction, position, var}.\\
  \rel{If\_Constant}{instruction, position, constant}.\\
  \rel{DummyIf\_Var}{instruction, var}.\\
  \rel{Operator\_At}{instruction, operator}.\\
  \captionof{figure}{Imported facts}
  \label{fig:imported-facts}
\end{figure}

The relations described thus far are only a small set of the input to our reasoning, as we have
made use of the various relations and rules that were already existed in \doop{}. Here we have
only presented the brand new input relations or the ones that we modified. However we can
not provide an extensive presentation of all, thus we will briefly describe them in the
following sections, in the context of the rules that they are used.

Our symbolic reasoning approach namely reasons about a program's possible expressions. That
said, there is a need for the representation of a program's expression, either primitive ones
or not. \doop{} does not include such an encoding, due to the fact that its analyses mainly
reason about pointers. In order to address that and also lay the foundations of our approach,
we have introduced the following types as described in figure \ref{fig:expr-type}.

\begin{figure}[th]
  \type{SymbolicInput}\singlefield{Var | MethodInvocation | NumConstant}\\
  \type{Operator}\singlefield{symbol}\\
  \type{ExpressionType}\singlefield{PrimitiveType | ReferenceType}\\
  \type{Base}\singlefield{SymbolicInput | Operator}\\
  \type{Expr}\typefields{\tab base: Base}{\tab type: ExpressionType}{\tab left: Expr}{\tab right: Expr}\\
  \captionof{figure}{Expression Type}
  \label{fig:expr-type}
\end{figure}

The types that are defined using a (\dl{|}) symbol are said to inherit from the
associated types, whilst the latter definition introduces a new record type. The
expression type manages to represent both unary, binary and constant expressions at the same time,
by distinguishing each case with the help of the \emph{base} field. If base is of type
\emph{SymbolicInput} then the latter \emph{Expr} fields are nil, whilst in the case of
base being of \emph{Operator} at least the first of the Expr fields is indeed an expression.
For each distinct expression we also preserve its type, which can either be
\emph{PrimitiveType} or \emph{ReferenceType}. Those types are the building blocks for the
construction of the program's expression. It may come natural to the reader that
the encoding leads to complex \emph{expression trees}. This expression type is essentially
what powers our declarative symbolic reasoning approach, encoding both the primitive
expressions of the input program and its control flow constructs at the same time.

\subsection{Relations}

We here provide a brief presentation of the \emph{main} declared relations that make our
approach work in figure \ref{fig:main-relations}.

\begin{figure}[th]
  \declkeyword \tab \rel{ResolveExpr}{meth: Method, var: symbol, expr: Expr}\\
  \declkeyword \tab \rel{isExpr}{expr: Expr}\\
  \declkeyword \tab \rel{isArithmeticExpr}{expr: Expr}\\
  \declkeyword \tab \rel{isReferenceExpr}{expr: Expr}\\
  \declkeyword \tab \rel{isBooleanExpr}{expr: Expr}\\
  \declkeyword \tab \rel{isBooleanExprLeftRight}{exprOther: Expr, exprX: Expr, exprY: Expr,\\
    \hspace*{60mm}op: Operator}\\
  \declkeyword \tab \rel{isBooleanExprLeftRightInMethod}{exprOther: Expr, exprX: Expr, exprY: Expr,\\
    \hspace*{76mm}op: Operator, meth: Method}\\
  \declkeyword \tab \rel{BuildPathExprBefore}{meth:Method, prev:Instruction, exprBase: Expr,\\
    \hspace*{51mm} insn:Instruction}\\
  \declkeyword \tab \rel{PathExpressionBefore}{meth:Method, insn: Instruction, pathExpr: Expr}\\
  \declkeyword \tab \rel{PathExpressionAfterTrue}{meth: Method, insn: Instruction, pathExpr: Expr}\\
  \declkeyword \tab \rel{PathExpressionAfterFalse}{meth: Method, insn: Instruction, pathExpr: Expr}\\
  \declkeyword \tab \rel{ExprImpliesOther}{expr: Expr, exprOther: Expr}\\
  \declkeyword \tab \rel{ExprIsAlwaysTrue}{expr: Expr}\\
  \declkeyword \tab \rel{ExprIsAlwaysFalse}{expr: Expr}\\
  \declkeyword \tab \rel{ExprIsNegationOfOther}{expr: Expr, exprOther: Expr}\\
  \captionof{figure}{Main Symbolic Reasoning relations}
  \label{fig:main-relations}
\end{figure}

Those relations and their associated rules are going to be thoroughly described in the
following section where we will be introducing the main parts of \emph{declarative symbolic reasonig}.
\emph{ResolveExpr} is the main relation that constructs the program's expressions that yield
from the input statements and expressions, whilst the \emph{PathExpression*} relations are responsible
for the construction of the control flow expressions, that is essentially encoding the
branches taken up to as specific program point. Lastly, our declarative symbolic reasoner
is powered by the rules of \emph{ExprImpliesOther}, \emph{ExprIsAlwaysTrue}, \emph{ExprIsAlwaysFalse}
and \emph{ExprIsNegationOfOther} relations, attempting to prove \emph{implications} between the expressions
and assert those that hold \emph{true} or \emph{false} equivalently, if possible.\\

\section{Program Expression Trees}

% Expressions produced by the resolve expr for the example program
% Description of the rules related to the ResolveExpr relation, omitting some details

Introducing a Souffle type that represents a program's expressions is only one
step towards symbolic reasoning of a program. For our reasoner to be able to provide us
with meaningful results we have to generate its world of expressions. To that end, we
have introduced several rules that build expression trees from the given program's
input relations which essentially encode the expressions of a program in a symbolic
manner. The first set of those rules originate from the \emph{ResolveExpr} relation
that was declared in figure \ref{fig:main-relations} of the previous section.

The ResolveExpr rules are divided into two sets of rules. The ones that encode
the base, \emph{symbolic input} expressions and those that lead to the construction of the
complex composite expressions. Symbolic input expressions namely represent the
symbolic inputs of a method. We consider (a) method parameters, (b) method invocation
results, (c) instance and static fields loading, (d) numeric constant assignments and
(e) phi assignments as symbolic inputs. Those input cases form the basis of our
expressions, and it also worts mentioning that our reasoner mainly asserts any new
knowledge in an intra-procedural fashion. The rules for the enumerated symbolic
input expressions are presented in the following figures.

\begin{figure}[h]
\begin{minipage}{.5\textwidth}
  \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
  \rel{isAssignLocal\_Insn}{?insn},\\
  \rel{AssignLocal\_From}{?insn, ?param},\\
  \rel{FormalParam}{\_, ?meth, ?param},\\
  \rel{Var\_Type}{?param, ?type},\\
  \rel{}{\rel{isPrimitiveType}{?type} ;\\
         \rel{isReferenceType}{?type}},\\
  \rel{AssignInstruction\_To}{?insn, ?var},\\
  \rel{Instruction\_Method}{?insn, ?meth},\\
  \record{?expr}\singlefieldbrackets{?param, ?type, nil, nil}.
  \captionof{figure}{(a) method parameter}
  \label{fig:params-a}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
  \rel{isMethodInvocation}{?insn},\\
  \rel{MethodInvocation\_Method}{?insn, ?sig},\\
  \rel{Method\_ReturnType}{?sig, \_, ?type},\\
  \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
  \rel{Instruction\_Method}{?insn, ?meth},\\
  \rel{AssignReturnValue}{?insn, ?var},\\
  \record{?expr}\singlefieldbrackets{?param, ?type, nil, nil}.\\
  \captionof{figure}{(b) method invocation results}
  \label{f:result-b}
\end{minipage}
\end{figure}

\begin{figure}[th]
  \begin{minipage}{.5\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{isLoadInstanceField\_Insn}{?insn},\\
    \rel{LoadInstanceField\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\ \rel{isReferenceType}{?type}},\\
    \rel{Instruction\_Method}{?insn, ?meth},\\
    \record{?expr}\singlefieldbrackets{?var, ?type, nil, nil}.\\
    \captionof{figure}{(c) load instance fields}
    \label{fig:field-c}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{isLoadInstanceField\_Insn}{?insn},\\
    \rel{LoadInstanceField\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\ \rel{isReferenceType}{?type}},\\
    \rel{Instruction\_Method}{?insn, ?meth},\\
    \record{?expr}\singlefieldbrackets{?var, ?type, nil, nil}.\\
    \captionof{figure}{(d) load static fields}
    \label{fig:field-d}
  \end{minipage}
\end{figure}

\begin{figure}[th]
  \begin{minipage}{.5\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{isAssignNumConstant\_Insn}{?insn},\\
    \rel{AssignInstruction\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \rel{Instruction\_Method}{?insn, ?meth},\\
    \rel{AssignNumConstant\_Id}{?insn, ?const},\\
    \record{?expr}\singlefieldbrackets{?const, ?type, nil, nil}.
  \captionof{figure}{(e) numeric assignments}
  \label{fig:ass-num}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{Instruction\_Method}{?insn, ?meth}\\
    \rel{isAssignLocal\_Insn}{?insn},\\
    \rel{AssignInstruction\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \record{c}\singlefield{count: \rel{AssignInstruction\_To}{\_, ?var}},\\
    \recordname{c}\singlefield{ > 1}, \record{?expr}\singlefieldbrackets{?var, ?type, nil, nil}.
  \captionof{figure}{(f) phi assignments}
  \label{fig:phi-ass}
  \end{minipage}
\end{figure}

The various relations used in the rules bodies are quite self-explanatory
which proves the expressiveness and high quality of \doop{}'s code.
In the following figures we present the recursive rules that apply for the
cases of (a) local variable assignments, (b) unary assignments,
(c) binary expression assignments and (d) if conditions.

\begin{figure}[th]
  \begin{minipage}{.54\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{Instruction\_Method}{?insn, ?meth}\\
    \rel{isAssignLocal\_Insn}{?insn},\\
    \rel{AssignInstruction\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \record{c}\singlefield{count: \rel{AssignInstruction\_To}{\_, ?var}},\\
    \recordname{c}\singlefield{ = 1}, \rel{AssicnLocal\_From}{?insn, ?from},\\
    \rel{ResolveExpr}{?meth, ?from, ?expr}.\\
  \end{minipage}
  \begin{minipage}{.46\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{isAssignUnop\_Insn}{?insn},\\
    \rel{AssignInstruction\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \rel{Instruction\_Method}{?insn, ?meth},\\
    \rel{AssignOper\_From}{?insn, \_, ?right},\\
    \rel{\_OperatorAt}{?insn, ?op},\\
    \rel{ResolveExpr}{?meth, ?right, ?rExpr},\\
    \record{?expr}\singlefieldbrackets{?op, ?type, ?rExpr, nil}.
  \end{minipage}
  \captionof{figure}{(a) local variable and (b) unary assignments}
  \label{fig:local-unary-ass}
  \begin{minipage}{.55\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{FUNCTION}{?var, ?right1, ?right2, ?op},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \rel{ResolveExpr}{?meth, ?right1, ?lExpr},\\
    \rel{ResolveExpr}{?meth, ?right2, ?rExpr},\\
    \record{?expr}\singlefieldbrackets{?op, ?type, ?lExpr, ?rExpr}.
  \end{minipage}
  \begin{minipage}{.46\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{FUNCTION}{?var, ?right1, ?right2, ?op},\\
    \rel{ResolveExpr}{?meth, ?right1, ?lExpr},\\
    \rel{ResolveExpr}{?meth, ?right2, ?rExpr},\\
    \record{?expr}\singlefieldbrackets{?op, "boolean", ?lExpr, ?rExpr}.
  \end{minipage}
  \captionof{figure}{(c) binary assignments and (d) if conditions}
  \label{fig:bin-ass-if-cond}
\end{figure}

For simplicity, several details have been omitted from the rules as defined in
figure \ref{fig:bin-ass-if-cond} and they have been hidden under the \emph{FUNCTION} relation.
This function relation is demonstration purposed only and it is responsible to emit
the appropriate variables and generate their corresponding expressions in either
case of binary expression assignment or if conditions for the rules to work.
It essentially attempts to generate the appropriate combination of operands
and expressions based on whether an operand is a constant or a variable.

% TODO: ResolveExpr relation facts produced for example Java program

As previously mentioned, the rules presented in this section constitute
one of the most fundamental parts of our reasoner. They construct the
most primitive, yet essential expressions of the anlyzed program. However,
the expressions are guarded in a sense that if unrolled, they would all
lead to complex expressions between symbolic expressions. We shall mention
here that any reasoning is purely symbolic, and thus there is not any concrete
evaluation of the expressions in the sense of constant folding. One could also
notice that even though the lack of boolean expressions up to this point. That
is due to the SSA IR upon which any reasoning happens. The various branches,
however complex they are are split into multiple simplified ones and thus we
have to kee track of these. In the following section we provide an overview of
the algorithm responsible for generating those boolean expressions that encode
the control flow construcs of the methods of the input program.

\section{Path Expressions}

Any \doop{} reasoning happens on facts produced at a lower level IR
called Jimple, Soot's IR. Jimple omits several complex constructs,
such as boolean expressions. In our case though, we need to have an exact
representation of those high level control flow constructs in order to be
able to reason about a program and answer several useful questions about
it. In order to further facilitate and enhance our core symbolic reasoning
technique we have introduced several algoritms that are responsible for the
reconstruction of those expressions, that namely represent the program's branch
conditions or complete path predicates.

% TODO: add jimple CFG of our example program

Even though the analyzed program is quite simplified and the various complex
control flow structures have been lowered to way simpler forms, the reconstruction
of the desired predicates is not trivial at all. Complex expressions between operands
that contain operators such as $\&\&$, $||$ and $!$ have been simplified
to three-address code (TAC) that completely trim those operators in favour of
if statements with simplified boolean conditions. Even though we could modify
the code transformer that lowers the initial program in a way that would avoid those
transformations, we decided to preserve any external framework functionality as
it is, implementing any predicate reformation in pure Datalog. Following
we introduce the algorithm that implements the desired funcionality in two parts.
For the shake of pure logic formality we consider $\land$, $\lor$ and $\neg$ the equivalents of
\emph{and}, \emph{or} and \emph{negation} operators.

At first we provide a high level overview of the algorithms responsible
for the restoration of the boolean predicates. The basis of each predicate is
the first boolean expression met in the program, that is usual the first
branch instrucion. The algorithm keeps track of the path predicates at any
program point before and after each instruction. Each branch instruction splits
two distinct path predicates, whilst any other instruction does not produce
any new path predicate but rather emits the predicate that holds at the program
point before it. However, an instruction may have more than
a single predecessors that lead the execution path
up to the program point before it. The decision to consider only a single predecessor
would lead to inaccurate results as several program paths would have been lost. In
order for our algorithm to yield sound path predicates we join the
expressions that hold after each predecessor at the program point before such an
instruction. Recall that any reasoning is symbolic and there is not any cocrete
evaluation, thus we can not be sure of what path predicates should be discarded.
This brief introduction reveals that our algorithm needs to implement
the following two functionalities: (a) the enumeration of all possible predecessors
of an instruction and (b) the making of the path predicates for every program
point.

% TODO: Path expressions based on the example program

\section{Boolean Symbolic Reasoning}

% Expression reasoning for the program

\subsection{Propositional Logic Axioms}

\subsection{Propositional Logic Inference Rules}
