\chapter{Static Declarative Symbolic Reasoning}\label{c:main-content}

In this chapter we present our approach towards static declarative
symbolic reasoning. The main core of the reasoning is encoded as a
bunch of Souffle Datalog rules, along with the related input facts.
\doop{} includes a whole of preprocessing, expressive analyses and
postprocessing pieces that can be leveraged to enhance the core of
our reasoning at relatively swift speed.

\section{Schema Relations and Types}

\subsection{Input Facts and Types}

\doop{} includes a set of fact generators that provide us with an
extensive set of input facts that may be leveraged for our reasoning.
Those generators either target different input languages or different
intermediate representations (IR). As an example, there are generators
that target the Java language, Android technology or Python. Those
generators may further utilize different tools that would take care
the translation of the input program into the corresponding IR; the
current tools being used by \doop{} are namely Soot and WALA. In the case of
Java, the generators ought to produce the same set of input facts
that \doop{} consumes for its main analyses, and thus there is a set
of files that define the common predicates-facts that should be
produced by the generators. The existing set of generated
facts is quite extensive and it is constantly further enriched, yet it
does not provide us with a set of facts crucial for the reasoning
we introduce. Hosting a rich whole of various pointer analyses,
\doop{} mainly needs knowledge that is related to pointers, or
in the Java setting reference types. As such, \doop{} lacks
presence of multiple facts in regard to primitive types or
values and in the case that they exist they are relatively
non-adequate. In that notion we decided to modify the common fact
generator in a way that enhances \doop{} with facts to be consumed
by our symbolic reasoning approach, or modifies several existing ones.
At the same time those facts may also come handy for \doop{} itself
in the future. In order to be able to construct a fine-grained
analysis we modified a certain amount of facts as follows in figure \ref{fig:facts-modified}.

\begin{figure}[th]
\rel{\_AssignOperFrom}{instruction, position, from}.\\
\rel{\_IfVar}{instruction, position, var}.
\captionof{figure}{Modified \doop{} facts}
\label{fig:facts-modified}
\end{figure}

\_AssignOperFrom introduces a new position variable that keeps track of
each subsequent operand of an instruction's right-hand side (rhs), whilst
the same also holds for \_IfVar too. Next, we provide a glimpse of all the
newly introduced generated facts in figure \ref{fig:facts-new}.

\begin{figure}[th]
  \rel{\_OperatorAt}{instruction, operator}.\\
  \rel{\_DummyIfVar}{instruction, var}.\\
  \rel{\_AssignOperFromConstant}{instruction, position, from}.\\
  \rel{\_IfConstant}{instruction, position, constant}.
  \captionof{figure}{New \doop{} facts}
  \label{fig:facts-new}
\end{figure}

Those input facts share many similarities in regards to the associated
variables - relation columns - though each one encodes crucial knowledge.
The \_OperatorAt relation holds facts that encode the operation being present
at a given instruction. \_AssignOperFromConstant is an alternate rule of \_AssignOperFrom,
whilst \_IfConstant is equivalent to \_IfVar. A constant type is different to a variable type
in the context of the framework, thus the need for a more detailed differentiation between the
two. Such differentiations have extensively been made during the development of our approach, but
in many cases will be omitted in the context of this text.
Lastly, the \_DummyIfVar relation has been introduced in order to encode the conditional
expressions at a given branch instruction, that is quite necessary to our implementation
and its need is evoked due to the IR provide by Soot. It is also worth mentioning that
the facts and the associated relations as described above are provided by the generators
written in Java. Mere preprocessing takes place before importing the final facts into \doop{}'s
knowledge base in order to follow its conventions. That preprocessing leads to the following
renames as described in figure \ref{fig:imported-facts}.

\begin{figure}[th]
  \rel{AssignOper\_From}{instruction, position, from}.\\
  \rel{AssignOper\_FromConstant}{instruction, position, from}.\\
  \rel{If\_Var}{instruction, position, var}.\\
  \rel{If\_Constant}{instruction, position, constant}.\\
  \rel{DummyIf\_Var}{instruction, var}.\\
  \rel{Operator\_At}{instruction, operator}.\\
  \captionof{figure}{Imported facts}
  \label{fig:imported-facts}
\end{figure}

The relations described thus far are only a small set of the input to our reasoning, as we have
made use of the various relations and rules that were already existed in \doop{}. Here we have
only presented the brand new input relations or the ones that we modified. However we can
not provide an extensive presentation of all, thus we will briefly describe them in the
following sections, in the context of the rules that they are used.

Our symbolic reasoning approach namely reasons about a program's possible expressions. That
said, there is a need for the representation of a program's expression, either primitive ones
or not. \doop{} does not include such an encoding, due to the fact that its analyses mainly
reason about pointers. In order to address that and also lay the foundations of our approach,
we have introduced the following types as described in figure \ref{fig:expr-type}.

\begin{figure}[th]
  \type{SymbolicInput}\singlefield{Var | MethodInvocation | NumConstant}\\
  \type{Operator}\singlefield{symbol}\\
  \type{ExpressionType}\singlefield{PrimitiveType | ReferenceType}\\
  \type{Base}\singlefield{SymbolicInput | Operator}\\
  \type{Expr}\typefields{\tab base: Base}{\tab type: ExpressionType}{\tab left: Expr}{\tab right: Expr}\\
  \captionof{figure}{Expression Type}
  \label{fig:expr-type}
\end{figure}

The types that are defined using a (\dl{|}) symbol are said to inherit from the
associated types, whilst the latter definition introduces a new record type. The
expression type manages to represent both unary, binary and constant expressions at the same time,
by distinguishing each case with the help of the \emph{base} field. If base is of type
\emph{SymbolicInput} then the latter \emph{Expr} fields are nil, whilst in the case of
base being of \emph{Operator} at least the first of the Expr fields is indeed an expression.
For each distinct expression we also preserve its type, which can either be
\emph{PrimitiveType} or \emph{ReferenceType}. Those types are the building blocks for the
construction of the program's expression. It may come natural to the reader that
the encoding leads to complex \emph{expression trees}. This expression type is essentially
what powers our declarative symbolic reasoning approach, encoding both the primitive
expressions of the input program and its control flow constructs at the same time.

\subsection{Relations}

We here provide a brief presentation of the \emph{main} declared relations that make our
approach work in figure \ref{fig:main-relations}.

\begin{figure}[th]
  \declkeyword \tab \rel{ResolveExpr}{meth: Method, var: symbol, expr: Expr}\\
  \declkeyword \tab \rel{isExpr}{expr: Expr}\\
  \declkeyword \tab \rel{isArithmeticExpr}{expr: Expr}\\
  \declkeyword \tab \rel{isReferenceExpr}{expr: Expr}\\
  \declkeyword \tab \rel{isBooleanExpr}{expr: Expr}\\
  \declkeyword \tab \rel{isBooleanExprLeftRight}{exprOther: Expr, exprX: Expr, exprY: Expr,\\
    \hspace*{60mm}op: Operator}\\
  \declkeyword \tab \rel{isBooleanExprLeftRightInMethod}{exprOther: Expr, exprX: Expr, exprY: Expr,\\
    \hspace*{76mm}op: Operator, meth: Method}\\
  \declkeyword \tab \rel{BuildPathExprBefore}{meth:Method, prev:Instruction, exprBase: Expr,\\
    \hspace*{51mm} insn:Instruction}\\
  \declkeyword \tab \rel{PathExpressionBefore}{meth:Method, insn: Instruction, pathExpr: Expr}\\
  \declkeyword \tab \rel{PathExpressionAfterTrue}{meth: Method, insn: Instruction, pathExpr: Expr}\\
  \declkeyword \tab \rel{PathExpressionAfterFalse}{meth: Method, insn: Instruction, pathExpr: Expr}\\
  \declkeyword \tab \rel{ExprImpliesOther}{expr: Expr, exprOther: Expr}\\
  \declkeyword \tab \rel{ExprIsAlwaysTrue}{expr: Expr}\\
  \declkeyword \tab \rel{ExprIsAlwaysFalse}{expr: Expr}\\
  \declkeyword \tab \rel{ExprIsNegationOfOther}{expr: Expr, exprOther: Expr}\\
  \captionof{figure}{Main Symbolic Reasoning relations}
  \label{fig:main-relations}
\end{figure}

Those relations and their associated rules are going to be thoroughly described in the
following section where we will be introducing the main parts of \emph{declarative symbolic reasonig}.
\emph{ResolveExpr} is the main relation that constructs the program's expressions that yield
from the input statements and expressions, whilst the \emph{PathExpression*} relations are responsible
for the construction of the control flow expressions, that is essentially encoding the
branches taken up to as specific program point. Lastly, our declarative symbolic reasoner
is powered by the rules of \emph{ExprImpliesOther}, \emph{ExprIsAlwaysTrue}, \emph{ExprIsAlwaysFalse}
and \emph{ExprIsNegationOfOther} relations, attempting to prove \emph{implications} between the expressions
and assert those that hold \emph{true} or \emph{false} equivalently, if possible.\\

\section{Program Expression Trees}

% Expressions produced by the resolve expr for the example program
% Description of the rules related to the ResolveExpr relation, omitting some details

Introducing a Souffle type that represents a program's expressions is only one
step towards symbolic reasoning of a program. For our reasoner to be able to provide us
with meaningful results we have to generate its world of expressions. To that end, we
have introduced several rules that build expression trees from the given program's
input relations which essentially encode the expressions of a program in a symbolic
manner. The first set of those rules originate from the \emph{ResolveExpr} relation
that was declared in figure \ref{fig:main-relations} of the previous section.

The ResolveExpr rules are divided into two sets of rules. The ones that encode
the base, \emph{symbolic input} expressions and those that lead to the construction of the
complex composite expressions. Symbolic input expressions namely represent the
symbolic inputs of a method. We consider (a) method parameters, (b) method invocation
results, (c) instance and static fields loading, (d) numeric constant assignments and
(e) phi assignments as symbolic inputs. Those input cases form the basis of our
expressions, and it also worts mentioning that our reasoner mainly asserts any new
knowledge in an intra-procedural fashion. The rules for the enumerated symbolic
input expressions are presented in the following figures.

\begin{figure}[h]
\begin{minipage}{.5\textwidth}
  \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
  \rel{isAssignLocal\_Insn}{?insn},\\
  \rel{AssignLocal\_From}{?insn, ?param},\\
  \rel{FormalParam}{\_, ?meth, ?param},\\
  \rel{Var\_Type}{?param, ?type},\\
  \rel{}{\rel{isPrimitiveType}{?type} ;\\
         \rel{isReferenceType}{?type}},\\
  \rel{AssignInstruction\_To}{?insn, ?var},\\
  \rel{Instruction\_Method}{?insn, ?meth},\\
  \record{?expr}\singlefieldbrackets{?param, ?type, nil, nil}.
  \captionof{figure}{(a) method parameter}
  \label{fig:params-a}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
  \rel{isMethodInvocation}{?insn},\\
  \rel{MethodInvocation\_Method}{?insn, ?sig},\\
  \rel{Method\_ReturnType}{?sig, \_, ?type},\\
  \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
  \rel{Instruction\_Method}{?insn, ?meth},\\
  \rel{AssignReturnValue}{?insn, ?var},\\
  \record{?expr}\singlefieldbrackets{?param, ?type, nil, nil}.\\
  \captionof{figure}{(b) method invocation results}
  \label{f:result-b}
\end{minipage}
\end{figure}

\begin{figure}[th]
  \begin{minipage}{.5\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{isLoadInstanceField\_Insn}{?insn},\\
    \rel{LoadInstanceField\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\ \rel{isReferenceType}{?type}},\\
    \rel{Instruction\_Method}{?insn, ?meth},\\
    \record{?expr}\singlefieldbrackets{?var, ?type, nil, nil}.\\
    \captionof{figure}{(c) load instance fields}
    \label{fig:field-c}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{isLoadInstanceField\_Insn}{?insn},\\
    \rel{LoadInstanceField\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\ \rel{isReferenceType}{?type}},\\
    \rel{Instruction\_Method}{?insn, ?meth},\\
    \record{?expr}\singlefieldbrackets{?var, ?type, nil, nil}.\\
    \captionof{figure}{(d) load static fields}
    \label{fig:field-d}
  \end{minipage}
\end{figure}

\begin{figure}[th]
  \begin{minipage}{.5\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{isAssignNumConstant\_Insn}{?insn},\\
    \rel{AssignInstruction\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \rel{Instruction\_Method}{?insn, ?meth},\\
    \rel{AssignNumConstant\_Id}{?insn, ?const},\\
    \record{?expr}\singlefieldbrackets{?const, ?type, nil, nil}.
  \captionof{figure}{(e) numeric assignments}
  \label{fig:ass-num}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{Instruction\_Method}{?insn, ?meth}\\
    \rel{isAssignLocal\_Insn}{?insn},\\
    \rel{AssignInstruction\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \record{c}\singlefield{count: \rel{AssignInstruction\_To}{\_, ?var}},\\
    \recordname{c}\singlefield{ > 1}, \record{?expr}\singlefieldbrackets{?var, ?type, nil, nil}.
  \captionof{figure}{(f) phi assignments}
  \label{fig:phi-ass}
  \end{minipage}
\end{figure}

The various relations used in the rules bodies are quite self-explanatory
which proves the expressiveness and high quality of \doop{}'s code.
In the following figures we present the recursive rules that apply for the
cases of (a) local variable assignments, (b) unary assignments,
(c) binary expression assignments and (d) if conditions.

\begin{figure}[th]
  \begin{minipage}{.54\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{Instruction\_Method}{?insn, ?meth}\\
    \rel{isAssignLocal\_Insn}{?insn},\\
    \rel{AssignInstruction\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \record{c}\singlefield{count: \rel{AssignInstruction\_To}{\_, ?var}},\\
    \recordname{c}\singlefield{ = 1}, \rel{AssicnLocal\_From}{?insn, ?from},\\
    \rel{ResolveExpr}{?meth, ?from, ?expr}.\\
  \end{minipage}
  \begin{minipage}{.46\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{isAssignUnop\_Insn}{?insn},\\
    \rel{AssignInstruction\_To}{?insn, ?var},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \rel{Instruction\_Method}{?insn, ?meth},\\
    \rel{AssignOper\_From}{?insn, \_, ?right},\\
    \rel{\_OperatorAt}{?insn, ?op},\\
    \rel{ResolveExpr}{?meth, ?right, ?rExpr},\\
    \record{?expr}\singlefieldbrackets{?op, ?type, ?rExpr, nil}.
  \end{minipage}
  \captionof{figure}{(a) local variable and (b) unary assignments}
  \label{fig:local-unary-ass}
  \begin{minipage}{.55\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{FUNCTION}{?var, ?right1, ?right2, ?op},\\
    \rel{Var\_Type}{?var, ?type},\\
    \rel{}{\rel{isPrimitiveType}{?type} ;\\
      \rel{isReferenceType}{?type}},\\
    \rel{ResolveExpr}{?meth, ?right1, ?lExpr},\\
    \rel{ResolveExpr}{?meth, ?right2, ?rExpr},\\
    \record{?expr}\singlefieldbrackets{?op, ?type, ?lExpr, ?rExpr}.
  \end{minipage}
  \begin{minipage}{.46\textwidth}
    \rel{ResolveExpr}{?meth, ?var, ?expr} \rulearrow\\
    \rel{FUNCTION}{?var, ?right1, ?right2, ?op},\\
    \rel{ResolveExpr}{?meth, ?right1, ?lExpr},\\
    \rel{ResolveExpr}{?meth, ?right2, ?rExpr},\\
    \record{?expr}\singlefieldbrackets{?op, "boolean", ?lExpr, ?rExpr}.
  \end{minipage}
  \captionof{figure}{(c) binary assignments and (d) if conditions}
  \label{fig:bin-ass-if-cond}
\end{figure}

For simplicity, several details have been omitted from the rules as defined in
figure \ref{fig:bin-ass-if-cond} and they have been hidden under the \emph{FUNCTION} relation.
This function relation is demonstration purposed only and it is responsible to emit
the appropriate variables and generate their corresponding expressions in either
case of binary expression assignment or if conditions for the rules to work.
It essentially attempts to generate the appropriate combination of operands
and expressions based on whether an operand is a constant or a variable.

% TODO: ResolveExpr relation facts produced for example Java program

As previously mentioned, the rules presented in this section constitute
one of the most fundamental parts of our reasoner. They construct the
most primitive, yet essential expressions of the anlyzed program. However,
the expressions are guarded in a sense that if unrolled, they would all
lead to complex expressions between symbolic expressions. We shall mention
here that any reasoning is purely symbolic, and thus there is not any concrete
evaluation of the expressions in the sense of constant folding. One could also
notice that even though the lack of boolean expressions up to this point. That
is due to the SSA IR upon which any reasoning happens. The various branches,
however complex they are are split into multiple simplified ones and thus we
have to kee track of these. In the following section we provide an overview of
the algorithm responsible for generating those boolean expressions that encode
the control flow construcs of the methods of the input program.

\section{Path Expressions}

Any \doop{} reasoning happens on facts produced at a lower level IR
called Jimple, Soot's IR. Jimple omits several complex constructs,
such as boolean expressions. In our case though, we need to have an exact
representation of those high level control flow constructs in order to be
able to reason about a program and answer several useful questions about
it. In order to further facilitate and enhance our core symbolic reasoning
technique we have introduced several algoritms that are responsible for the
reconstruction of those expressions, that namely represent the program's branch
conditions or complete path predicates.

% TODO: add jimple CFG of our example program

Even though the analyzed program is quite simplified and the various complex
control flow structures have been lowered to way simpler forms, the reconstruction
of the desired predicates is not trivial at all. Complex expressions between operands
that contain operators such as $\&\&$, $||$ and $!$ have been simplified
to three-address code (TAC) that completely trim those operators in favour of
if statements with simplified boolean conditions. Even though we could modify
the code transformer that lowers the initial program in a way that would avoid those
transformations, we decided to preserve any external framework functionality as
it is, implementing any predicate reformation in pure Datalog. Following
we introduce the algorithm that implements the desired funcionality in two parts.
For the shake of pure logic formality we consider $\land$, $\lor$ and $\neg$ the equivalents of
\emph{and}, \emph{or} and \emph{negation} operators.

At first we provide a high level overview of the algorithms responsible
for the restoration of the boolean predicates. The basis of each predicate is
the first boolean expression met in the program, that is usual the first
branch instrucion. The algorithm keeps track of the path predicates at any
program point before and after each instruction. Each branch instruction splits
two distinct path predicates, whilst any other instruction does not produce
any new path predicate but rather emits the predicate that holds at the program
point before it. However, an instruction may have more than
a single predecessors that lead the execution path
up to the program point before it. The decision to consider only a single predecessor
would lead to inaccurate results as several program paths would have been lost. In
order for our algorithm to yield sound path predicates we join the
expressions that hold after each predecessor at the program point before such an
instruction. Recall that any reasoning is symbolic and there is not any cocrete
evaluation, thus we can not be sure of what path predicates should be discarded.
This brief introduction reveals that our algorithm needs to implement
the following two functionalities: (a) the enumeration of all possible predecessors
of an instruction and (b) the making of the path predicates for every program
point.

In the following figures we are going to introduce the algorithmic parts responsible
for the instruction predecessors enumeration. The whole logic is implemented in
pure Datalog rules like the rest of our work. \doop{} contains a set of rules
populating relations that represent various control flow constructs, such as
the set of basic blocks in each function which we made use of. The simplest case
of this enumeration is the single predecessor case. We present the relations
and the associated rules for this one, along with the \emph{helper} rules that populate the
relations which keep track of the first and last predecessor of an instruction in
the following figures.

\begin{figure}[th]
  \begin{minipage}{.7\textwidth}
    \begin{tabular}{l}
  \rel{SinglePredOfInsnInMethod}{?pred, ?insn, ?meth} \rulearrow\\
  \tab \rel{Instruction\_Method}{?insn, ?meth},\\
  \tab \rel{FirstPredOfInsnInMethod}{?meth, ?pred, ?insn},\\
  \tab \rel{LastPredOfInsnInMethod}{?meth, ?pred, ?insn}.
\end{tabular}
  \captionof{figure}{Single predecessor rules.}
  \label{fig:single-pred}
\end{minipage}
\begin{minipage}{.7\textwidth}
  \begin{tabular}{l}
  \rel{FirstPredOfInsnInMethodOrdinal}{?meth, ?firstOrd, ?insn} \rulearrow \\
  \tab \rel{Instruction\_Method}{?insn, ?meth},\\
  \tab \recordname{?firstOrd}\singlefield{ = min ord(?prev): \rel{MayPredecessorModuloThrow}{?prev, ?insn}}.\\\\
  \rel{FirstPredOfInsnInMethod}{?meth, ?first, ?insn} \rulearrow \\
  \tab \rel{Instruction\_Method}{?insn, ?meth},\\
  \tab \rel{MayPredecessorModuloThrow}{?first, ?insn},\\
  \tab \recordname{?min\_ord}\singlefield{ = ord(?first)},\\
  \tab \rel{FirstPredOfInsnInMethodOrdinal}{?meth, ?min\_ord, ?insn}.
\end{tabular}
  \captionof{figure}{First predecessor of instruction in method}
  \label{fig:first-pred}
\end{minipage}
\begin{minipage}{.7\textwidth}
  \begin{tabular}{l}
  \rel{LastPredOfInsnInMethodOrdinal}{?meth, ?lastOrd, ?insn} \rulearrow \\
  \tab \rel{Instruction\_Method}{?insn, ?meth},\\
  \tab \recordname{?lastOrd}\singlefield{ = max ord(?prev): \rel{MayPredecessorModuloThrow}{?prev, ?insn}}.\\\\
  \rel{LastPredOfInsnInMethod}{?meth, ?last, ?insn} \rulearrow \\
  \tab \rel{Instruction\_Method}{?insn, ?meth},\\
  \tab \rel{MayPredecessorModuloThrow}{?last, ?insn},\\
  \tab \recordname{?max\_ord}\singlefield{ = ord(?last)},\\
  \tab \rel{LastPredOfInsnInMethodOrdinal}{?meth, ?max\_ord, ?insn}.
\end{tabular}
\captionof{figure}{Last predecessor of instruction in method}
\label{fig:last-pred}
\end{minipage}
\end{figure}

The above rules introduce the handling of the least complicated cases. With just
a few rules we manage to identify the one and only predecessor of an instruction.
In figure \ref{fig:single-pred} we present the rule that populates the relation
keeping track of the single predecessors of an instruction which is powered by
the rules of FirstPredOfInsnInMethod and LastPredOfInsnInMethod relations. In those
two presented in figures \ref{fig:first-pred} and \ref{fig:last-pred} we leverage
\doop{}'s control-flow graph (CFG) analysis by using the
MayPredecessorModuloThrow relation that provides us with the predecessors of an
instrucion. We further aggregate with the help of min and max aggregation functions
of Souffle in order to distinguish the first and last predecessors of an instruction
accordingly. Those rules are also utilized during the enumeration of the multiple
predecessors of a single instruction, but they are wrapped into complex rules that
separate the multiple to the single predecessor case. We present those wrappers
in figure \ref{fig:pred-wrappers}.

\begin{figure}[th]
  \begin{tabular}{l}
    \rel{FirstOfMultiplePredsOfInsnInMethod}{?pred, ?insn, ?meth} \rulearrow\\
    \tab \rel{Instruction\_Method}{?insn, ?meth},\\
    \tab \rel{FirstPredOfInsnInMethod}{?meth, ?pred, ?insn},\\
    \tab \rel{!LastPredOfInsnInMethod}{?meth, ?pred, ?insn}.\\

    \rel{LastOfMultiplePredsOfInsnInMethod}{?pred, ?insn, ?meth} \rulearrow\\
    \tab \rel{Instruction\_Method}{?insn, ?meth},\\
    \tab \rel{!FirstPredOfInsnInMethod}{?meth, ?pred, ?insn},\\
    \tab \rel{LastPredOfInsnInMethod}{?meth, ?pred, ?insn}.
  \end{tabular}
  \captionof{figure}{First and last of multiple predecessors wrappers}
  \label{fig:pred-wrappers}
\end{figure}

The negation of LastPredOfInsnInMethod in the first rule is required so that
the FirstOfMultiplePredsOfInsnInMethod relation considers instructions
with multiple predecessors.\\
Otherwise it would be equivalent to the
SinglePredOfInsnInMethod relation, whilst the same also holds for the
LastOfMultiplePredsOfInsnInMethod. Having introduced the first and last
predecessors rules for either case, there is the need of introducing the
rules of the relations associated with yielding an ordering of each
distinct predecessor. Datalog does not come with any explicit iteration syntax,
thus we need to come with a way to enumerate those possible predecessors in a
recursive style. We present the steps towards the multiple predecessors enumeration
in figure \ref{fig:pred-ordering}.

\begin{figure}[th]
  \begin{tabular}{l}
    \rel{NotNextPredOfInsnInMethod}{?meth, ?prev, ?next, ?insn} \rulearrow\\
    \tab \rel{Instruction\_Method}{?insn, ?meth},\\
    \tab \rel{MayPredecessorModuloThrow}{?prev, ?insn},\\
    \tab \rel{MayPredecessorModuloThrow}{?next, ?insn},\\
    \tab \rel{MayPredecessorModuloThrow}{?nextPossible, ?insn},\\
    \tab \rel{ord}{?prev} < \rel{ord}{?next},\\
    \tab \rel{ord}{?prev} < \rel{ord}{?nextPossible},\\
    \tab \rel{ord}{?nextPossible} < \rel{ord}{?next}.\\\\

    \rel{NextPredOfInsnInMethod}{?meth, ?prev, ?next, ?insn} \rulearrow\\
    \tab \rel{Instruction\_Method}{?insn, ?meth},\\
    \tab \rel{MayPredecessorModuloThrow}{?prev, ?insn},\\
    \tab \rel{MayPredecessorModuloThrow}{?next, ?insn},\\
    \tab \rel{ord}{?prev} < \rel{ord}{?next},\\
    \tab \rel{!NotNextPredOfInsnInMethod}{?meth, ?prev, ?next, ?insn}.\\\\

    \rel{NextOfMultiplePredsOfInsnInMethod}{?next, ?prev, ?insn, ?meth} \rulearrow\\
    \tab \rel{Instruction\_Method}{?insn, ?meth},\\
    \tab \rel{!LastPredOfInsnInMethod}{?meth, ?prev, ?insn},\\
    \tab \rel{NextPredOfInsnInMethod}{?meth, ?prev, ?next, ?insn}.

  \end{tabular}
  \captionof{figure}{Predecessors ordering rules}
  \label{fig:pred-ordering}
\end{figure}

The last rule in figure \ref{fig:pred-ordering} is yet again a wrapper which is used
for the predecessors enumeration. It populates the associated relation excluding the
last predecessor. Even though there are many different ways to tackle this problem, we
decided to provide an interim relation which when negated yields the next predecessor
in the enumeration. The rule feeding that relation, named NotNextPredOfInsnInMethod, considers
the previous and next possible predecessor of an instruction and asserts that in case there is
another one between them the rule shall fail. Thus, the negation of this relation yields the
actual next possible predecessors which are then used to proceed with the enumeration.

After introducing the part responsible for the predecessors enumeration,
we may proceed to the main algorithm that creates the path predicates at every single program
point. A high level overview of the algorithm has been provided earlier,
and we now present the core rules of this part in the following figures. We have already
introduced the notion of \emph{before} and \emph{after} program points in the context of
a distinct instruction and at first we describe the rules responsible for the
construction of the path predicates after an instruction via the PathExpressionAfterTrue and
PathExpressionAfterFalse relations.

\begin{figure}[th]
  \begin{tabular}{l}
    \rel{PathExpressionAfterTrue}{?meth, ?insn, ?cond},\\
    \rel{PathExpressionAfterFalse}{?meth, ?insn, ?negatedCond} \rulearrow\\
    \tab \rel{FirstIfInsnInMethod}{?insn, ?meth},\\
    \tab \rel{NegationOfConditionAtIfInsn}{?cond, ?negatedCond, ?insn}.\\\\

    \rel{PathExpressionAfterTrue}{?meth, ?insn, ?pathExpr1},\\
    \rel{PathExpressionAfterFalse}{?meth, ?insn, ?pathExpr2} \rulearrow \\
    \tab \rel{PathExpressionBefore}{?meth, ?insn, ?pathExpr},\\
    \tab \rel{NegationOfConditionAtIfInsn}{?cond, ?negatedCond, ?insn},\\
    \tab \record{?cond}\singlefieldbrackets{?op, ?type, ?exprLeft, ?exprRight},\\
    \tab \record{?pathExpr1}\singlefieldbrackets{"\&\&", ?type, ?cond, ?pathExpr},\\
    \tab \record{?pathExpr2}\singlefieldbrackets{"\&\&", ?type, ?negatedCond, ?pathExpr}.\\\\

    \rel{PathExpressionAfterTrue}{?meth, ?insn, ?pathExpr} \rulearrow\\
    \tab \rel{PathExpressionBefore}{?meth, ?insn, ?pathExpr},\\
    \tab \rel{!isIf\_Insn}{?insn}.
  \end{tabular}
  \captionof{figure}{Path expressions after an instruction}
  \label{fig:path-after}
\end{figure}

The path expression predicates are split into two dsjoint sets of \emph{true} and \emph{false}
conjuncts due to the separation of a program path after a branch instruction. A branch
instruction leads to different execution paths based on whether the condition succeeds or not.
In order to differentiate between the two, we have introduced the
NegationOfConditionAtIfInsn relation that
yields the negated condition of a branch condition that would be used to
generate the complement of a path predicate. The first rule in figure \ref{fig:path-after}
represents the basis of any path predicate formation, whist the second one further
splits each path predicate into two subsequent expressions. The last rule represents
the path predicate after any statement that is not a branch instruction. However, those
rules heavily depend on the existence of path predicates on the program point right
before each instruction. In figures \ref{fig:path-before} 
we present the rules of the relations that yield the path predicates at the
program point before each instruction for the single predecessor case.

\begin{figure}[th]
  \begin{tabular}{l}
    \rel{PathExpressionBefore}{?meth, ?insn, ?expr} \rulearrow \\
    \tab \rel{PathExpressionAfterTrue}{?meth, ?pred, ?expr},\\
    \tab \rel{SinglePredOfInsnInMethod}{?pred, ?insn, ?meth},\\
    \tab \rel{isIf\_Insn}{?pred}, \rel{isJumpTarget}{?insn}.\\\\

    \rel{PathExpressionBefore}{?meth, ?insn, ?expr} \rulearrow \\
    \tab \rel{PathExpressionAfterFalse}{?meth, ?pred, ?expr},\\
    \tab \rel{SinglePredOfInsnInMethod}{?pred, ?insn, ?meth},\\
    \tab \rel{isIf\_Insn}{?pred}, \rel{!isJumpTarget}{?insn}.\\\\

    \rel{PathExpressionBefore}{?meth, ?insn, ?expr} \rulearrow \\
    \tab \rel{PathExpressionAfterTrue}{?meth, ?pred, ?expr},\\
    \tab \rel{SinglePredOfInsnInMethod}{?pred, ?insn, ?meth},\\
    \tab \rel{!isIf\_Insn}{?pred}.\\\\
  \end{tabular}
  \begin{tabular}{l}
  \end{tabular}
  \captionof{figure}{Path expressions before an instruction - single predecessor }
  \label{fig:path-before}
\end{figure}

The complicated case of the construction of the before-path predicates is essentially when
an instruction has multiple predecessors that flow up to it. In order to facilitate the
rules of the relation PathExpressionBefore, we introduced the BuildPathExprBefore relation,
responsible for constructing a disjunct of all the predecessor path
expressions that meet at the program point right before the instruction. The former
relation rules utilize the predecessor enumeration relations introduced before, by
implicitly enumerating all over the predecessors. Lastly, we present the logic of
the disjunct formation in figure \ref{fig:path-before-multiple}.

\begin{figure}[h]
  \begin{tabular}{l}
    \rel{PathExpressionBefore}{?meth, ?insn, ?pathExpr} \rulearrow\\ 
    \tab \rel{LastOfMultiplePredsOfInsnInMethod}{?pred, ?insn, ?meth},\\
    \tab \rel{BuildPathExprBefore}{?meth, ?pred, ?pathExpr, ?insn}.\\
    \rel{BuildPathExprBefore}{?meth, ?pred,  ?expr, ?insn} \rulearrow\\
    \tab \rel{FirstOfMultiplePredsOfInsnInMethod}{?pred, ?insn, ?meth},\\
    \tab \rel{isIf\_Insn}{?pred},\\
    \tab \rel{IsJumpTarget}{?insn},\\
    \tab \rel{PathExpressionAfterTrue}{?meth, ?pred, ?expr}.\\

    \rel{BuildPathExprBefore}{?meth, ?pred,  ?expr, ?insn} \rulearrow\\
    \tab \rel{FirstOfMultiplePredsOfInsnInMethod}{?pred, ?insn, ?meth},\\
    \tab \rel{isIf\_Insn}{?pred},\\
    \tab \rel{!IsJumpTarget}{?insn},\\
    \tab \rel{PathExpressionAfterFalse}{?meth, ?pred, ?expr}.\\

    \rel{BuildPathExprBefore}{?meth, ?pred,  ?expr, ?insn} \rulearrow\\
    \tab \rel{FirstOfMultiplePredsOfInsnInMethod}{?pred, ?insn, ?meth},\\
    \tab \rel{!isIf\_Insn}{?pred},\\
    \tab \rel{PathExpressionAfterTrue}{?meth, ?pred, ?expr}.\\

    \rel{BuildPathExprBefore}{?meth, ?next,  ?pathExpr, ?insn} \rulearrow\\
    \tab \rel{BuildPathExprBefore}{?meth, ?prev, ?expr, ?insn},\\
    \tab \rel{NextOfMultiplePredsOfInsnInMethod}{?next, ?prev, ?insn, ?meth},\\
    \tab \rel{!isIf\_Insn}{?next},\\
    \tab \rel{PathExpressionAfterTrue}{?meth, ?next, ?exprPrev},\\
    \tab \record{?pathExpr}\singlefieldbrackets{"||", "boolean", ?expr, ?exprPrev}.\\

    \rel{BuildPathExprBefore}{?meth, ?next,  ?pathExpr, ?insn} \rulearrow\\
    \tab \rel{BuildPathExprBefore}{?meth, ?prev, ?expr, ?insn},\\
    \tab \rel{NextOfMultiplePredsOfInsnInMethod}{?next, ?prev, ?insn, ?meth},\\
    \tab \rel{isIf\_Insn}{?next},\\
    \tab \rel{isJumpTarget}{?insn},\\
    \tab \rel{PathExpressionAfterTrue}{?meth, ?next, ?exprPrev},\\
    \tab \record{?pathExpr}\singlefieldbrackets{"||", "boolean", ?expr, ?exprPrev}.\\

    \rel{BuildPathExprBefore}{?meth, ?next,  ?pathExpr, ?insn} \rulearrow\\
    \tab \rel{NextOfMultiplePredsOfInsnInMethod}{?next, ?prev, ?insn, ?meth},\\
    \tab \rel{BuildPathExprBefore}{?meth, ?prev, ?expr, ?insn},\\
    \tab \rel{isIf\_Insn}{?next},\\
    \tab \rel{!isJumpTarget}{?insn},\\
    \tab \rel{PathExpressionAfterTrue}{?meth, ?next, ?exprPrev},\\
    \tab \record{?pathExpr}\singlefieldbrackets{"||", "boolean", ?expr, ?exprPrev}.
  \end{tabular}
  \captionof{figure}{Path expression before multiple predecessors}
  \label{fig:path-before-multiple}
\end{figure}

All of the rules introduced in this section generate the boolean logic formulas,
disjuncts and conjuncts. Those formulas are modeled with the help of the
expression type introduced during the first sections of this thesis. We may now
proceed to the description of the core algorithm of our analysis, static
declarative symbolic reasoning.

\section{Boolean Symbolic Reasoning}

A symbolic reasoner mainly deduces knowledge about the expressions of a program and may get
as complex as one wants to. Such tool is essentially a theorem prover that given a
friendly input representation and a set of guiding facts tries to reason about a program
by constructing proofs with the help of a set of inferrence rules. In the context of this
work we have introduced a fundamental symbolic reasoner that mainly deduces knowledge about the
boolean expressions of a program in a purely symbolic manner. That is, our reasoner
contains pure propositional logic formulas and it
does not concretely evaluate any expression on the fly, but rather constantly emits
new knowledge until a fixpoint is reached: there can be no more knowledge produced by
the set of inferrence rules. In this chapter we exhibit the core implementation of our
reasoner by describing the set of propositional logic axioms and inferrence rules that
bring into life our technique. The whole of those axioms and rules are implemented as
pure Datalog rules, without the help of any external tool. The main work of the reasoner
is to ask the question of \emph{``What are the program expressions that are implied by another program expression?"}.

\subsection{Propositional Logic Axioms}

\subsection{Propositional Logic Inference Rules}
